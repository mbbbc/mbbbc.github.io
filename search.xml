<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hibernate学习笔记Part4]]></title>
    <url>%2F2018%2F09%2F21%2FHibernate%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part4%2F</url>
    <content type="text"><![CDATA[下面通过代码演示Hibernate支持的三种查询吧。有精力再来填坑吧。。 1.HQL相关查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172package com.mbc.test;import java.util.Arrays;import java.util.List;import org.hibernate.Query;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import com.mbc.domain.Customer;import com.mbc.domain.User;import com.mbc.util.HibernateUtil;/** * 测试HQL相关查询 * @author MBC * */public class Test3 &#123; @Test public void test1() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.HQL的简单查询 Query query = session.createQuery("from User"); List&lt;User&gt; list = query.list(); for (User user : list) &#123; System.out.println(user); &#125; transaction.commit(); &#125; @Test public void test2() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //2.HQL的别名查询// Query query = session.createQuery("from User u"); Query query = session.createQuery("select u from User u"); List&lt;User&gt; list = query.list(); for (User user : list) &#123; System.out.println(user); &#125; transaction.commit(); &#125; @Test public void test3() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //3.HQL的排序查询 //默认为升序排序// Query query = session.createQuery("from User order by user_id"); //desc为降序，asc为升序 Query query = session.createQuery("from User order by user_id desc"); List&lt;User&gt; list = query.list(); for (User user : list) &#123; System.out.println(user); &#125; transaction.commit(); &#125; @Test public void test4() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //4.条件查询 //(1)按位置绑定，根据参数的位置进行绑定 //单个条件// Query query = session.createQuery("from User where user_id = ?");// query.setParameter(0, 4L); //多个条件// Query query = session.createQuery("from User where user_id = ? and user_name= ?");// query.setParameter(0, 5L);// query.setParameter(1, "小红");// List&lt;User&gt; list = query.list(); //(2)按名称绑定 Query query = session.createQuery("from User where user_id = :id and user_name = :name"); query.setParameter("id", 5L); query.setParameter("name", "小红"); List&lt;User&gt; list = query.list(); for (User user: list) &#123; System.out.println(user); &#125; transaction.commit(); &#125; @Test public void test5() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //5.投影查询 //(1)查询单个属性// List&lt;Object&gt; list = session.createQuery("select user_name from User").list(); //(2)查询多个属性// List&lt;Object[]&gt; list = session.createQuery("select user_id,user_name from User").list();// for (Object[] obj: list) &#123;// System.out.println(Arrays.toString(obj));// &#125; //(3)查询多个属性，并封装到对象中 List&lt;User&gt; list = session.createQuery("select new User(user_id, user_name) from User").list(); for (User user : list) &#123; System.out.println(user); &#125; transaction.commit(); &#125; @Test public void test6() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //6.分页查询 Query query = session.createQuery("from User"); query.setFirstResult(0); query.setMaxResults(10); List&lt;User&gt; list = query.list(); for (User user : list) &#123; System.out.println(user); &#125; transaction.commit(); &#125; @Test public void test7() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //7.分组查询 //聚合函数的使用：count(),max(),min(),avg(), sum() Object result = session.createQuery("select count(*) from User").uniqueResult(); System.out.println(result); //分组统计 List&lt;Object[]&gt; list = session.createQuery("select user_name, count(*) from User group by user_code").list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125; transaction.commit(); &#125; @Test public void test8() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //8.多表查询 //内连接// String hql = "from Customer c inner join c.linkMans";// List&lt;Object[]&gt; list = session.createQuery(hql).list();// for (Object[] obj : list) &#123;// System.out.println(Arrays.toString(obj));// &#125; //迫切内连接:在inner join后添加关键字fetch //通知hibernate，将查询到的数据封装到某一个对象中 String hql = "from Customer c inner join fetch c.linkMans"; List&lt;Customer&gt; list = session.createQuery(hql).list(); for (Customer obj : list) &#123; System.out.println(obj); &#125; transaction.commit(); &#125;&#125; 2. QBC查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.mbc.test;import java.util.List;import org.hibernate.Criteria;import org.hibernate.Session;import org.hibernate.Transaction;import org.hibernate.criterion.DetachedCriteria;import org.hibernate.criterion.Order;import org.hibernate.criterion.Projections;import org.hibernate.criterion.Restrictions;import org.junit.Test;import com.mbc.domain.Customer;import com.mbc.domain.User;import com.mbc.util.HibernateUtil;/** * QBC查询 * @author MBC * */public class Test4 &#123; //1.简单查询 @Test public void test1() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //获得Criteria对象 Criteria criteria = session.createCriteria(User.class); List&lt;User&gt; list = criteria.list(); for (User user : list) &#123; System.out.println(user); &#125; transaction.commit(); &#125; //2.排序查询 @Test public void test2() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //获得Criteria对象 Criteria criteria = session.createCriteria(User.class); //降序 criteria.addOrder(Order.desc("user_id")); //升序(默认)// criteria.addOrder(Order.asc("user_id")); List&lt;User&gt; list = criteria.list(); for (User user : list) &#123; System.out.println(user); &#125; transaction.commit(); &#125; //3.分页查询 @Test public void test3() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //获得Criteria对象 Criteria criteria = session.createCriteria(User.class); criteria.setFirstResult(0); criteria.setMaxResults(10); List&lt;User&gt; list = criteria.list(); for (User user : list) &#123; System.out.println(user); &#125; transaction.commit(); &#125; //4.条件查询 @Test public void test4() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //获得Criteria对象 Criteria criteria = session.createCriteria(User.class); //各个条件被封装成Restrictions中的方法 // =:eq,&gt;:gt,&gt;=ge,&lt;:lt,&lt;=le,&lt;&gt;:ne,like,in,and,or criteria.add(Restrictions.eq("user_id", 3L)); criteria.add(Restrictions.like("user_name", "%小%")); List&lt;User&gt; list = criteria.list(); for (User user : list) &#123; System.out.println(user); &#125; transaction.commit(); &#125; //5.统计查询 @Test public void test5() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //获得Criteria对象 Criteria criteria = session.createCriteria(User.class); /** * add:普通条件。where后面条件 * addOrder:排序 * setProjection:聚合函数和group by having */ criteria.setProjection(Projections.rowCount()); Long result = (Long)criteria.uniqueResult(); System.out.println(result); transaction.commit(); &#125; //6.离线查询 -- DetachedCriteria //无需通过session来获得相应的查询对象，可以在需要查询的时候再传入对象 @Test public void test6() &#123; DetachedCriteria criteria = DetachedCriteria.forClass(User.class); criteria.add(Restrictions.eq("user_id", 5L)); Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); Criteria executableCriteria = criteria.getExecutableCriteria(session); List&lt;User&gt; list = executableCriteria.list(); for (User user: list) &#123; System.out.println(user); &#125; transaction.commit(); &#125;&#125; 3. SQL查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.mbc.test;import java.util.Arrays;import java.util.List;import org.hibernate.SQLQuery;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import com.mbc.domain.Customer;import com.mbc.domain.User;import com.mbc.util.HibernateUtil;/** * 通过SQL查询 * @author MBC * */public class Test5 &#123; @Test public void test1() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); SQLQuery sqlQuery = session.createSQLQuery("select * from sys_user"); //使用Object数组接收每一行数据 List&lt;Object[]&gt; list = sqlQuery.list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125; transaction.commit(); &#125; @Test public void test2() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); SQLQuery sqlQuery = session.createSQLQuery("select * from sys_user"); sqlQuery.addEntity(User.class); List&lt;User&gt; list = sqlQuery.list(); for (User user : list) &#123; System.out.println(user); &#125; transaction.commit(); &#125;&#125;]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate学习笔记Part3]]></title>
    <url>%2F2018%2F09%2F21%2FHibernate%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part3%2F</url>
    <content type="text"><![CDATA[1. 数据库表与表之间的关系1.1 一对多关系一对多的关系 （1）一个部门对应多个员工，一个员工只能属于一个部门。 （2）一个客户对应多个联系人，一个联系人只能属于某一个客户 一对多的建表原则 在多的一方创建外键指向一的一方的主键。 1.2 多对多关系多对多的关系 （1）一个学生可以选择多门课程，一门课程也可以被多个学生选择。 （2）一个用户可以选择多个角色，一个角色也可以被多个用户选择。 多对多的建表原则 创建一个中间表，中间表至少有两个字段分别作为外键指向多对多双方的主键。 2. Hibernate一对多的关系配置2.1 创建一个项目，引入相应的jar包2.2 创建数据库和表1234567891011121314151617181920212223242526CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', `cust_name` varchar(32) NOT NULL COMMENT '客户名称(公司名称)', `cust_source` varchar(32) DEFAULT NULL COMMENT '客户信息来源', `cust_industry` varchar(32) DEFAULT NULL COMMENT '客户所属行业', `cust_level` varchar(32) DEFAULT NULL COMMENT '客户级别', `cust_phone` varchar(64) DEFAULT NULL COMMENT '固定电话', `cust_mobile` varchar(16) DEFAULT NULL COMMENT '移动电话', PRIMARY KEY (`cust_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;CREATE TABLE `cst_linkman` ( `lkm_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '联系人编号(主键)', `lkm_name` varchar(16) DEFAULT NULL COMMENT '联系人姓名', `lkm_cust_id` bigint(32) DEFAULT NULL COMMENT '客户id', `lkm_gender` char(1) DEFAULT NULL COMMENT '联系人性别', `lkm_phone` varchar(16) DEFAULT NULL COMMENT '联系人办公电话', `lkm_mobile` varchar(16) DEFAULT NULL COMMENT '联系人手机', `lkm_email` varchar(64) DEFAULT NULL COMMENT '联系人邮箱', `lkm_qq` varchar(16) DEFAULT NULL COMMENT '联系人qq', `lkm_position` varchar(16) DEFAULT NULL COMMENT '联系人职位', `lkm_memo` varchar(512) DEFAULT NULL COMMENT '联系人备注', PRIMARY KEY (`lkm_id`), KEY `FK_cst_linkman_lkm_cust_id` (`lkm_cust_id`), CONSTRAINT `FK_cst_linkman_lkm_cust_id` FOREIGN KEY (`lkm_cust_id`) REFERENCES `cst_customer` (`cust_id`) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 2.3 创建实体1234567891011121314151617package com.mbc.domain;import java.util.HashSet;import java.util.Set;public class Customer &#123; private Long cust_id; private String cust_name; private String cust_source; private String cust_industry; private String cust_level; private String cust_phone; private String cust_mobile; //放置多的一方的集合。Hibernate默认使用的是Set集合 private Set&lt;LinkMan&gt; linkMans = new HashSet&lt;LinkMan&gt;(); //省略get/set方法&#125; 12345678910111213141516package com.mbc.domain;public class LinkMan &#123; private Long lkm_id; private String lkm_name; private String lkm_gender; private String lkm_phone; private String lkm_mobile; private String lkm_email; private String lkm_qq; private String lkm_position; private String lkm_memo; //放置一的一方的对象 private Customer customer; //省略get/set方法&#125; 2.4 创建映射文件1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.mbc.domain.LinkMan" table="cst_linkman"&gt; &lt;!-- 建立OID与表字段映射 --&gt; &lt;id name="lkm_id" column="lkm_id"&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;!-- 建立普通属性与表字段映射 --&gt; &lt;property name="lkm_name" /&gt; &lt;property name="lkm_gender" /&gt; &lt;property name="lkm_phone" /&gt; &lt;property name="lkm_mobile" /&gt; &lt;property name="lkm_email" /&gt; &lt;property name="lkm_qq" /&gt; &lt;property name="lkm_position" /&gt; &lt;property name="lkm_memo" /&gt; &lt;!-- 配置多对一的关系 --&gt; &lt;!-- name: 一的一方的对象的属性名称 --&gt; &lt;!-- class: 一的一方的类的全路径 --&gt; &lt;!-- column: 多的一方的外键的名称 --&gt; &lt;many-to-one name="customer" class="com.mbc.domain.Customer" column="lkm_cust_id"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.mbc.domain.Customer" table="cst_customer"&gt; &lt;id name="cust_id" column="cust_id"&gt; &lt;generator class="native" /&gt; &lt;/id&gt; &lt;property name="cust_name"/&gt; &lt;property name="cust_source"/&gt; &lt;property name="cust_industry"/&gt; &lt;property name="cust_level"/&gt; &lt;property name="cust_phone"/&gt; &lt;property name="cust_mobile"/&gt; &lt;!-- name: 多的一方的对象集合的属性名称 --&gt; &lt;set name="linkMans"&gt; &lt;!-- column: 多的一方的外键名称 --&gt; &lt;key column="lkm_cust_id"&gt;&lt;/key&gt; &lt;!-- 多的一方的类的全路径 --&gt; &lt;one-to-many class="com.mbc.domain.LinkMan"/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 2.5 创建核心配置文件123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt; &lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 连接数据库的基本参数 --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://localhost/hibernate_day3&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;root&lt;/property&gt; &lt;!-- 配置Hibernate的方言 --&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 可选配置 --&gt; &lt;!-- 打印SQL --&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;!-- 格式化SQL --&gt; &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt; &lt;!-- 设置事务的隔离级别 --&gt; &lt;property name="hibernate.connection.isolation"&gt;4&lt;/property&gt; &lt;!-- 配置当前线程绑定的Session --&gt; &lt;property name="hibernate.current_session_context_class"&gt;thread&lt;/property&gt; &lt;!-- 引入映射文件 --&gt; &lt;mapping resource="com/mbc/domain/Customer.hbm.xml"/&gt; &lt;mapping resource="com/mbc/domain/LinkMan.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 2.6 引入工具类1234567891011121314151617181920212223package com.mbc.util;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class HibernateUtil &#123; public static final Configuration CFG; public static final SessionFactory SF; static &#123; CFG = new Configuration().configure(); SF = CFG.buildSessionFactory(); &#125; public static Session openSession() &#123; return SF.openSession(); &#125; public static Session getCurrentSession() &#123; return SF.getCurrentSession(); &#125;&#125; 2.7 编写测试类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.mbc.test;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import com.mbc.domain.Customer;import com.mbc.domain.LinkMan;import com.mbc.util.HibernateUtil;/** * 一对多的测试 * */public class Test1 &#123; /** * 保存两个客户和三个联系人，并且建立好关系 */ @Test public void test1() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //创建两个客户 Customer customer1 = new Customer(); customer1.setCust_name("mikasa"); Customer customer2 = new Customer(); customer2.setCust_name("hanji"); //创建三个联系人 LinkMan linkMan1 = new LinkMan(); linkMan1.setLkm_name("bingzhang"); LinkMan linkMan2 = new LinkMan(); linkMan2.setLkm_name("ailun"); LinkMan linkMan3 = new LinkMan(); linkMan3.setLkm_name("aerming"); //创建关系 linkMan1.setCustomer(customer1); linkMan2.setCustomer(customer1); linkMan3.setCustomer(customer2); customer1.getLinkMans().add(linkMan1); customer1.getLinkMans().add(linkMan2); customer2.getLinkMans().add(linkMan3); //保存数据 session.save(linkMan1); session.save(linkMan2); session.save(linkMan3); session.save(customer1); session.save(customer2); transaction.commit(); &#125;&#125; 3. Hibernate的一对多的相关操作3.1 一对多关系只保存一边是否可以1234567891011121314151617181920@Test//测试一对多关系只保存一边是否可以public void test2() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); Customer customer = new Customer(); customer.setCust_name("keni"); LinkMan linkMan = new LinkMan(); linkMan.setLkm_name("shaxia"); customer.getLinkMans().add(linkMan); linkMan.setCustomer(customer); //只保存一边是否可以？不可以，因为持久态对象关联了一个瞬时态对象 session.save(linkMan); session.save(customer); transaction.commit();&#125; 3.2 一对多的级联操作级联：指的是操作一个对象的时候，是否会同时操作其关联的对象。 级联的方向性 (1) 操作一的一方的时候，是否操作到多的一方。 (2) 操作多的一方的时候，是否操作到一的一方。 3.3 级联保存或更新(1) 保存一的一方，级联保存或更新多的一方 通过保存客户(一)级联联系人(多)来演示。 在一的映射表中配置级联保存或更新，即在set标签中添加属性cascade=&quot;save-update&quot;123456&lt;set name="linkMans" cascade="save-update"&gt; &lt;!-- column: 多的一方的外键名称 --&gt; &lt;key column="lkm_cust_id"&gt;&lt;/key&gt; &lt;!-- 多的一方的类的全路径 --&gt; &lt;one-to-many class="com.mbc.domain.LinkMan"/&gt;&lt;/set&gt; 测试代码12345678910111213141516171819@Test//已经在一的一边开启了级联保存//测试一对多关系中，保存一的一边级联保存多的一边public void test3() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); Customer customer = new Customer(); customer.setCust_name("keni"); LinkMan linkMan = new LinkMan(); linkMan.setLkm_name("shaxia"); customer.getLinkMans().add(linkMan); linkMan.setCustomer(customer); //保存一的一边即可 session.save(customer); transaction.commit();&#125; (2) 保存多的一方，级联保存或更新一的一方 在多的一方开启级联保存或更新，在many-to-one标签添加cascade=&quot;save-update&quot;属性 1&lt;many-to-one name="customer" cascade="save-update" class="com.mbc.domain.Customer" column="lkm_cust_id"/&gt; 测试代码12345678910111213141516171819@Test//已经在多的一边开启了级联保存//测试一对多关系中，保存多的一边级联保存一的一边public void test4() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); Customer customer = new Customer(); customer.setCust_name("keni"); LinkMan linkMan = new LinkMan(); linkMan.setLkm_name("shaxia"); customer.getLinkMans().add(linkMan); linkMan.setCustomer(customer); //保存多的一边即可 session.save(linkMan); transaction.commit();&#125; 3.4 级联删除级联删除：删除一边的时候，同时将另一方的数据也一并删除。 （1）下面演示删除客户级联删除联系人，在客户的映射文件中的配置如下1&lt;set name="linkMans" cascade="delete"&gt; 测试代码1234567891011121314//测试级联删除1@Testpublic void test6() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //未设置级联删除，修改联系人的外键为null，删除客户 /*Customer customer = session.get(Customer.class, 9L); session.delete(customer);*/ //设置级联删除，同时删除联系人 Customer customer = session.get(Customer.class, 10L); session.delete(customer); transaction.commit();&#125; （2）下面演示删除联系人级联删除客户(基本不使用)，在联系人的映射文件中的配置如下1&lt;many-to-one name="customer" cascade="delete" class="com.mbc.domain.Customer" column="lkm_cust_id"/&gt; 1234567891011//测试级联删除2@Testpublic void test7() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //删除联系人，同时删除客户 LinkMan linkMan = session.get(LinkMan.class, 15L); session.delete(linkMan); transaction.commit();&#125; 3.5 使一方放弃外键维护权若一对多中设置了双向关联，会产生多余的SQL更新语句，因为双方都对外键进行了维护。 以下的测试中，通过配置在一的一方配置inverse=&quot;true&quot;，来使一的一方放弃外键的维护权，来解决产生多余的SQL更新语句的问题。 12&lt;!-- inverse:true 表示放弃外键维护权 --&gt;&lt;set name="linkMans" cascade="save-update" inverse="true"&gt; 1234567891011121314//双向关联产生多余的SQL语句@Testpublic void test8() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); Customer customer = session.get(Customer.class, 12L); LinkMan linkMan = session.get(LinkMan.class, 21L); //双向关联 customer.getLinkMans().add(linkMan); linkMan.setCustomer(customer); transaction.commit();&#125; 4. Hibernate多对多关系的配置4.1 创建表用户表12345678CREATE TABLE `sys_user` ( `user_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '用户id', `user_code` varchar(32) NOT NULL COMMENT '用户账号', `user_name` varchar(64) NOT NULL COMMENT '用户名称', `user_password` varchar(32) NOT NULL COMMENT '用户密码', `user_state` char(1) NOT NULL COMMENT '1:正常,0:暂停', PRIMARY KEY (`user_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 角色表123456CREATE TABLE `sys_role` ( `role_id` bigint(32) NOT NULL AUTO_INCREMENT, `role_name` varchar(32) NOT NULL COMMENT '角色名称', `role_memo` varchar(128) DEFAULT NULL COMMENT '备注', PRIMARY KEY (`role_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 中间表12345678CREATE TABLE `sys_user_role` ( `role_id` bigint(32) NOT NULL COMMENT '角色id', `user_id` bigint(32) NOT NULL COMMENT '用户id', PRIMARY KEY (`role_id`,`user_id`), KEY `FK_user_role_user_id` (`user_id`), CONSTRAINT `FK_user_role_role_id` FOREIGN KEY (`role_id`) REFERENCES `sys_role` (`role_id`) ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT `FK_user_role_user_id` FOREIGN KEY (`user_id`) REFERENCES `sys_user` (`user_id`) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE=InnoDB DEFAULT CHARSET=utf8; 4.2 创建实体用户的实体 123456789public class User &#123; private Long user_id; private String user_code; private String user_name; private String user_password; private String user_state; //设置多对多关系，表示一个用户可以选择多个角色 private Set&lt;Role&gt; roles = new HashSet&lt;Role&gt;();&#125; 角色的实体 1234567public class Role &#123; private Long role_id; private String role_name; private String role_memo; //一个角色可以被多个用户选择 private Set&lt;User&gt; users = new HashSet&lt;User&gt;();&#125; 4.3 创建映射用户的映射1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.mbc.domain.User" table="sys_user"&gt; &lt;id name="user_id" column="user_id"&gt; &lt;generator class="native" /&gt; &lt;/id&gt; &lt;property name="user_code"/&gt; &lt;property name="user_name"/&gt; &lt;property name="user_password"/&gt; &lt;property name="user_state"/&gt; &lt;!-- table对应的中间表--&gt; &lt;set name="roles" table="sys_user_role"&gt; &lt;!-- column:当前对象对应中间表的外键的名称 --&gt; &lt;key column="user_id"&gt;&lt;/key&gt; &lt;!-- class:对方的类的全路径 column:对方对象在中间表中的外键的名称--&gt; &lt;many-to-many class="com.mbc.domain.Role" column="role_id"&gt; &lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 角色的映射1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.mbc.domain.Role" table="sys_role"&gt; &lt;id name="role_id" column="role_id"&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="role_name" /&gt; &lt;property name="role_memo" /&gt; &lt;set name="users" table="sys_user_role"&gt; &lt;key column="role_id"&gt;&lt;/key&gt; &lt;many-to-many class="com.mbc.domain.User" column="user_id"&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 4.4 编写测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.mbc.test;import org.hibernate.Hibernate;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import com.mbc.domain.Role;import com.mbc.domain.User;import com.mbc.util.HibernateUtil;/** * Hibernate的多对多映射 * @author MBC * */public class Test2 &#123; @Test public void test1() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //创建2个用户 User user1 = new User(); user1.setUser_name("小明1"); User user2 = new User(); user2.setUser_name("小明2"); //创建3个角色 Role role1 = new Role(); role1.setRole_name("学生"); Role role2 = new Role(); role2.setRole_name("儿子"); Role role3 = new Role(); role3.setRole_name("父亲"); //设置双向的关联关系 user1.getRoles().add(role1); user1.getRoles().add(role2); user2.getRoles().add(role2); user2.getRoles().add(role3); role1.getUsers().add(user1); role2.getUsers().add(user1); role2.getUsers().add(user2); role3.getUsers().add(user2); //保存操作，多对多建立了双向的关系必须有一方放弃外键维护 session.save(role1); session.save(role2); session.save(role3); session.save(user1); session.save(user2); transaction.commit(); &#125;&#125; 4.5 多对多的级联保存或更新保存用户级联保存角色 在用户的映射文件设置级联保存1&lt;set name="roles" table="sys_user_role" cascade="save-update"&gt; 测试：1234567891011121314151617@Testpublic void test2() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); User user = new User(); user.setUser_name("小红"); Role role = new Role(); role.setRole_name("普通学生"); //设置双向的关联关系 user.getRoles().add(role); role.getUsers().add(user); //只保存用户 session.save(user); transaction.commit();&#125;]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate学习笔记Part2]]></title>
    <url>%2F2018%2F09%2F20%2FHibernate%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part2%2F</url>
    <content type="text"><![CDATA[一、 Hibernate持久化类的编写规则1.1 什么是持久化类持久化：在Hibernate中指的是将内存中的数据永久存储到关系数据库中。 持久化类：指的是一个通过映射文件与数据库的表建立了关系的类。 可以理解为：持久化类 = Java类 + 映射文件。 1.2 持久化类的编写规则1. 对持久化类提供一个无参数的构造方法 原因：Hibernate底层需要使用反射生成实例 2. 属性需要私有，对私有属性提供public的get和set方法 原因：Hibernate中需要获取、设置对象的值 3. 持久化类提供一个唯一标识OID与数据库主键对应 原因：Hibernate中通过持久化类的OID的属性区分是否是同一个对象 4. 持久化类中属性尽量使用包装类类型 原因：基本数据类型默认是0，而0会存在歧义。例如一张表中存在一个字段为int类型，假设是salary，代表工资。若salary为0的话，那么就有可能会存在歧义。一种情况是：往表中添加数据时没有设置salary字段，那么salary字段就为默认的0。另一种情况假设是：本月的工资为0。那么当我们从表中查询出相应的记录时，若salary为0的话，我们就无法区分是哪一种情况。 若使用包装类的话，没有设置字段的情况就默认为null，若为0的话，直接设置为0即可。 5. 持久化类不要使用final进行修饰 原因：Hibernate中的延迟加载是使用javassist技术产生代理对象来实现的，而javassist技术是需要对持久化类进行继承。如果不能被继承，就不能产生代理对象，延迟加载也就失效了。 二、 Hibernate的主键生成策略2.1 主键的分类(1)自然主键：主键本身就是表中的字段，有实际的意义。 (2)代理主键：代理主键不是表中必须的一个字段，只是为了唯一地标识表中记录。 在实际的开发，通常会使用代理主键。因为自然主键是表中有实际意义的字段，无可避免的会与业务发生耦合(即可能会被使用)，不利于程序的维护。可以参考选择主键：自然键还是代理键？ 2.2 Hibernate的主键生成策略Hibernate中提供了很多种主键的生成策略，下面介绍常用的主键生成策略。 increment：Hibernate中提供的自动增长机制，适用short、int、long类型的主键，在单线程程序中使用。在此种生成策略中，Hibernate会从表中查询到最大的主键，然后使用最大的主键加1作为下一条记录的主键。 identity：使用的是数据库底层的自动增长机制，适用short、int、long类型的主键。适用于有自动增长机制的数据库（MySQL、MSSQL等），不使用于Oracle。 sequence：适用short、int、long类型的主键，采用的是序列的方式。适用于支持序列的数据库例如Oracle，MySQL不支持。 uuid：使用Hibernate中的随机方式生成字符串主键，适用于字符串类型的主键。 native：本机策略，根据数据库支持的方式在identity和sequence中切换。 assigned：Hibernate放弃对主键的管理，由程序员来进行设置。 在相应的映射文件中配置主键生成策略，在id标签下通过generator标签进行设置123&lt;id name="cust_id" column="cust_id"&gt; &lt;generator class="native"&gt;&lt;/generator&gt;&lt;/id&gt; 3. 持久化类的三种状态Hibernate为了更好地管理持久化类，将持久化类的对象分成三种状态，持久化类的对象可能处于三种不同状态中的某一种。 (1). 瞬时态：这种对象没有唯一的标识OID(相当于主键值)，没有与Hibernate中Session关联。 (2). 持久态：这种对象有唯一的标识OID，加入到了Session缓存中。持久态的对象可以自动更新数据库。 (3). 脱管态：这种对象有唯一的标识OID，失去了Session关联。 持久化类的三种状态之间的转换 下面通过代码来说明持久化类的三种状态1234567891011121314151617181920212223242526272829303132333435package com.mbc.test;import java.io.Serializable;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import com.mbc.domain.Customer;import com.mbc.util.HibernateUtil;public class Test1 &#123; /** * 持久类对象的三种状态 */ @Test public void testStatus() &#123; Session session = HibernateUtil.openSession(); Transaction transaction = session.beginTransaction(); //瞬时态对象，没有OID，没有与Session关联 Customer customer = new Customer(); customer.setCust_name("王五"); //持久态对象，有OID，加入了Session缓存中 Serializable id = session.save(customer); transaction.commit(); session.close(); //脱管态对象，失去了Session的关联 System.out.println("name = " + customer.getCust_name()); &#125;&#125; 持久态对象能自动更新数据库1234567891011121314@Testpublic void testPersistent() &#123; Session session = HibernateUtil.openSession(); Transaction transaction = session.beginTransaction(); //获得持久态对象 Customer customer = session.get(Customer.class, 9L); customer.setCust_name("小王"); //因为持久态对象能够自动更新数据库，所以不再需要执行以下的update方法 //session.update(customer); transaction.commit(); session.close();&#125; 4. Hibernate一级缓存4.1 什么是缓存缓存是介于应用程序和永久性数据存储源（如硬盘或数据库）之间，其作用是降低应用程序直接读写永久性数据存储源的频率，从而提高应用的运行性能。 4.2 Hibernate的缓存Hibernate的缓存分为一级缓存和二级缓存，Hibernate的两级缓存都位于持久层，存储都是数据库数据的备份。第一级缓存为Hibernate的内置缓存，不能被卸载，是Session级别的缓存。Hibernate的二级缓存是SessionFactory级别的缓存，需要进行配置才能使用。 4.3 Hibernate的一级缓存Hibernate的一级缓存，称为Session级别的缓存，一级缓存的生命周期与Session一致。 Hibernate一级缓存的特点 当调用Session接口的save()、update()、saveOrUpdate()时，如果Session中没有相应的对象，Hibernate会将对象放入一级缓存中。 当调用Session接口的load()、get()等方法时，会判断一级缓存中是否存在该对象，有则返回，不会查询数据库，如果缓存中没有再去查询数据库，并添加到一级缓存。 当调用Session的close()方法时，Session缓存会被清空。 即Hibernate通过一级缓存来缓存对象来减少对数据库的访问次数。 一级缓存的测试，测试Hibernate保存操作1234567891011121314151617@Testpublic void testSave() &#123; Session session = HibernateUtil.openSession(); Transaction transaction = session.beginTransaction(); Customer customer1 = new Customer(); customer1.setCust_name("啦啦啦"); Serializable id = session.save(customer1); //查看运行结果可知，只生成了插入数据库的SQL语句，没有生成查询的SQL语句 //说明了保存到数据库的同时，也在一级缓存中保留一份， //查询时，直接从缓存取出即可，无须再发送查询的SQL语句 Customer customer2 = session.get(Customer.class, id); System.out.println(customer2); transaction.commit(); session.close();&#125; 测试一级缓存的存在123456789101112131415@Testpublic void testGet() &#123; Session session = HibernateUtil.openSession(); Transaction transaction = session.beginTransaction(); //发送SQL语句查询数据，查询到的结果放在一级缓存中 Customer customer1 = session.get(Customer.class, 9L); System.out.println(customer1); //不发送SQL语句了，缓存中已存在，直接从缓存中取 Customer customer2 = session.get(Customer.class, 9L); System.out.println(customer2); transaction.commit(); session.close();&#125; 一级缓存的清空1234567891011121314151617@Testpublic void testClear() &#123; Session session = HibernateUtil.openSession(); Transaction transaction = session.beginTransaction(); //发送SQL语句查询数据 Customer customer1 = session.get(Customer.class, 9L); //清空缓存区 session.clear(); //缓存区已被清空，所以依然需要发送SQL语句查询数据 Customer customer2 = session.get(Customer.class, 9L); transaction.commit(); session.close();&#125; 5. Hibernate中的事务管理5.1 什么是事务事务：指的是逻辑上的一组操作，这组操作的各个逻辑单元要么全部成功，要么全部失败。 5.2 事务特性 原子性：代表事务不可分割 一致性：代表事务执行的前后，数据的完整性保持一致。 隔离性：代表一个事务执行的过程中，不应该受到其他事务的干扰。 持久性：代表事务执行完成后，数据就持久到数据库中。 5.3 不考虑隔离性，引发的安全性问题（1）读问题 脏读：一个事务读到了另一个事务未提交的事务 不可重复读：一个事务读到了另一个事务提交的update数据，导致前一个事务多次查询结果不一致。 虚读：一个事务读到了另一个事务已经提交的insert数据，导致在前一个事务多次查询结果不一致。 （2）写问题 引发两类丢失更新 5.4 读问题的解决可以通过设置事务的隔离级别，解决不考虑隔离性而引发的安全性问题。 事务的隔离级别： Read uncommitted：以上读问题都会发生 Read committed：解决脏读，但是不可重复读和虚读有可能发生 Repeatable read：解决脏读和不可重复读，但是虚读有可能发生 Serializable：解决所有读问题 5.5 在Hibernate中设置事务的隔离级别通过在Hibernate的核心配置文件(hibernate.cfg.xml)的标签下添加如下标签即可12&lt;!-- 设置事务的隔离级别 --&gt;&lt;property name="hibernate.connection.isolation"&gt;4&lt;/property&gt; 其中各个隔离级别以相应的数字来表示 Read uncommitted：1 Read committed： 2 Repeatable read： 4(默认) Serializable：8 5.6 在Service层开启事务因为DAO层的方法负责单一查询数据库的操作，而当业务逻辑比较复杂时，Service层需要使用某个DAO的多个方法或多个DAO的方法，并且需要保证Service中调用的方法都要成功执行。那么此时就不能再对DAO中某个方法开启事务了，而需要在Service层开启事务来保证调用的方法都能成功执行。 在Hibernate中，事务是通过一个Session来开启、提交的。那么我们可以在需要开启事务的Service层获得Session的对象来开启事务，然后把此Session对象传递给DAO层的方法即可。 那么如何把Session对象提供给DAO层的各个方法呢？ 把Session对象通过参数传递给DAO层方法。（有点麻烦啊！） 使用SessionFactory中提供的getCurrentSession方法，此方法提供了一个与当前线程绑定的Session对象。因为这些DAO层的方法都是在Service层中调用，即被Service层调用方法都在同一个线程上。 测试代码如下，另外使用getCurrentSession方法获取的Session对象不需要使用close()来关闭，是随着线程的结束而关闭123456789101112131415161718192021222324252627282930313233343536package com.mbc.test;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import com.mbc.domain.Customer;import com.mbc.util.HibernateUtil;public class Test2 &#123; public void dao1() &#123; Session session = HibernateUtil.getCurrentSession(); Customer customer = new Customer(); customer.setCust_name("ailun"); session.save(customer); &#125; public void dao2() &#123; Session session = HibernateUtil.getCurrentSession(); Customer customer = new Customer(); customer.setCust_name("sanli"); session.save(customer); &#125; /** * 使用与线程绑定的Session,在Service层开启事务 */ @Test public void testService() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); dao1(); dao2(); transaction.commit(); &#125;&#125; 在工具类中添加一个方法，用于获取与线程绑定的Session对象1234567891011121314151617181920212223package com.mbc.util;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class HibernateUtil &#123; public static final Configuration CFG; public static final SessionFactory SF; static &#123; CFG = new Configuration().configure(); SF = CFG.buildSessionFactory(); &#125; public static Session openSession() &#123; return SF.openSession(); &#125; //返回与线程绑定的Session对象 public static Session getCurrentSession() &#123; return SF.getCurrentSession(); &#125;&#125; 6. HQL、QBC的基本查询HQL 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.mbc.test;import java.util.List;import org.hibernate.Query;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import com.mbc.domain.Customer;import com.mbc.util.HibernateUtil;public class TestQuery &#123; /** * Hibernate的其他API的使用 * HQL查询 * HQL查询获取Query */ @Test public void TestQuery1() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //1.简单查询 String hql = "from Customer"; //获取Query对象 Query query = session.createQuery(hql); //把查询结果转为list List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit(); &#125; @Test public void TestQuery2() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //2.条件查询 String hql = "from Customer where cust_name=?"; Query query = session.createQuery(hql); query.setParameter(0, "sanli"); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit(); &#125; @Test public void TestQuery3() &#123; Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //3.分页查询 String hql = "from Customer"; Query query = session.createQuery(hql); //设置从哪条记录开始 query.setFirstResult(0); //设置一次查询几条记录 query.setMaxResults(5); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; transaction.commit(); &#125;&#125; QBC1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.mbc.test;import java.util.List;import org.hibernate.Criteria;import org.hibernate.Session;import org.hibernate.Transaction;import org.hibernate.criterion.Restrictions;import org.junit.Test;import com.mbc.domain.Customer;import com.mbc.util.HibernateUtil;public class TestCriteria &#123; /** * QBC(Query By Criteria)查询 * QBC查询获得Criteria对象 */ @Test public void Test1() &#123; //1.普通查询 Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); //获得Criteria对象 Criteria criteria = session.createCriteria(Customer.class); //把查询结果转为list List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; &#125; @Test public void Test2() &#123; //2.条件查询 Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = session.createCriteria(Customer.class); //添加条件 criteria.add(Restrictions.eq("cust_name", "sanli")); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; &#125; @Test public void Test3() &#123; //3.分页查询 Session session = HibernateUtil.getCurrentSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = session.createCriteria(Customer.class); //设置分页 criteria.setFirstResult(0); criteria.setMaxResults(10); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate学习笔记Part1 Hibernate入门]]></title>
    <url>%2F2018%2F09%2F19%2FHibernate%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0Part1-Hibernate%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1. Hibernate框架概述1.1 什么是框架框架：指的是软件的半成品，已经完成了部分功能。 1.2 什么是HibernateHibernate是一个持久层的ORM框架。它对JDBC进行了非常轻量级的对象封装，将POJO与数据库建立映射关系，是一个全自动的ORM框架。Hibernate可以自动生成SQL语句，自动执行，使得程序员可以随心所欲地使用对象编程思维来操纵数据库。 ORM：Object Relational Mapping，对象关系映射。指的是将一个Java中的对象(POJO)与关系型数据库中的表建立一种映射关系，从而操作对象就可以操作数据库中的表。 POJO：Plain Ordinary Java Object，简单的Java对象，实际就是普通JavaBeans。 1.3 Hibernate优点 Hibernate对JDBC访问数据库的代码做了轻量级封装，简化了数据访问层繁琐的重复性的代码。 Hibernate是一个优秀的ORM实现。 Hibernate支持很多关系型数据库，从一对一到多对多的各种复杂关系。 可扩展性强，由于源代码的开源以及API的开放，当本身功能不够用时，可以自行编码进行扩展。 2. Hibernate的入门程序2.1 下载Hibernate开发环境这里下载的是5.0.7版本，—&gt;传送门 2.2 解压Hibernate解压后Hibernate目录下可以看到有以下三个文件夹 documentation ：Hibernate开发文档 lib : Hibernate开发包 required : Hibernate开发的必须的jar包 optional : Hibernate开发的可选的jar包 project : Hibernate提供的项目 2.3 创建一个项目，引入jar包1.因为是对DAO层的操作，这里创建一个Java Project即可。 2.创建lib文件夹，引入以下jar包，并把jar包Add to Build Path (1) 数据库驱动包 这里我导入的是：mysql-connector-java-5.1.7-bin.jar (2) Hibernate开发的必须的jar包，即Hibernate目录下lib/required文件夹的jar包 (3) 引入日志记录包和log4j的配置文件(log4j.properties) 日志记录包： log4j-1.2.16.jar slf4j-api-1.6.1.jar slf4j-log4j12-1.7.2.jar log4j.properties123456789101112131415### direct log messages to stdout ###log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.errlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### direct messages to file mylog.log ###log4j.appender.file=org.apache.log4j.FileAppenderlog4j.appender.file.File=c\:mylog.loglog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### set log levels - for more verbose logging change &apos;info&apos; to &apos;debug&apos; #### error warn info debug tracelog4j.rootLogger= info, stdout 2.4 创建表12345678910CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT &apos;客户编号(主键)&apos;, `cust_name` varchar(32) NOT NULL COMMENT &apos;客户名称(公司名称)&apos;, `cust_source` varchar(32) DEFAULT NULL COMMENT &apos;客户信息来源&apos;, `cust_industry` varchar(32) DEFAULT NULL COMMENT &apos;客户所属行业&apos;, `cust_level` varchar(32) DEFAULT NULL COMMENT &apos;客户级别&apos;, `cust_phone` varchar(64) DEFAULT NULL COMMENT &apos;固定电话&apos;, `cust_mobile` varchar(16) DEFAULT NULL COMMENT &apos;移动电话&apos;, PRIMARY KEY (`cust_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 2.5 创建实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.mbc.domain;/** * * CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', `cust_name` varchar(32) NOT NULL COMMENT '客户名称(公司名称)', `cust_source` varchar(32) DEFAULT NULL COMMENT '客户信息来源', `cust_industry` varchar(32) DEFAULT NULL COMMENT '客户所属行业', `cust_level` varchar(32) DEFAULT NULL COMMENT '客户级别', `cust_phone` varchar(64) DEFAULT NULL COMMENT '固定电话', `cust_mobile` varchar(16) DEFAULT NULL COMMENT '移动电话', PRIMARY KEY (`cust_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; * */public class Customer &#123; private Long cust_id; private String cust_name; private String cust_source; private String cust_industry; private String cust_level; private String cust_phone; private String cust_mobile; public Long getCust_id() &#123; return cust_id; &#125; public void setCust_id(Long cust_id) &#123; this.cust_id = cust_id; &#125; public String getCust_name() &#123; return cust_name; &#125; public void setCust_name(String cust_name) &#123; this.cust_name = cust_name; &#125; public String getCust_source() &#123; return cust_source; &#125; public void setCust_source(String cust_source) &#123; this.cust_source = cust_source; &#125; public String getCust_industry() &#123; return cust_industry; &#125; public void setCust_industry(String cust_industry) &#123; this.cust_industry = cust_industry; &#125; public String getCust_level() &#123; return cust_level; &#125; public void setCust_level(String cust_level) &#123; this.cust_level = cust_level; &#125; public String getCust_phone() &#123; return cust_phone; &#125; public void setCust_phone(String cust_phone) &#123; this.cust_phone = cust_phone; &#125; public String getCust_mobile() &#123; return cust_mobile; &#125; public void setCust_mobile(String cust_mobile) &#123; this.cust_mobile = cust_mobile; &#125;&#125; 2.6 创建映射文件映射通过xml的配置文件来完成，这个配置文件通常的命名方式为(类名.hbm.xml) 在实体类相应的目录下创建Customer.hbm.xml文件12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;!-- 建立类与表的映射 --&gt; &lt;class name="com.mbc.domain.Customer" table="cst_customer"&gt; &lt;!-- 建立类中属性和表中的主键对应 --&gt; &lt;id name="cust_id" column="cust_id"&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;!-- 建立类中的普通属性和表的字段的对应 --&gt; &lt;property name="cust_name" column="cust_name" /&gt; &lt;property name="cust_source" column="cust_source" /&gt; &lt;property name="cust_industry" column="cust_industry" /&gt; &lt;property name="cust_level" column="cust_level" /&gt; &lt;property name="cust_phone" column="cust_phone" /&gt; &lt;property name="cust_mobile" column="cust_mobile" /&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 2.7 创建一个Hibernate的核心配置文件核心配置文件的名称：hibernate.cfg.xml，参考Hibernate目录下project/ect/hibernate.properties文件来进行配置 hibernate.cfg.xml12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt; &lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 连接数据库的基本参数 --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://localhost/hibernate_day1&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;root&lt;/property&gt; &lt;!-- 配置Hibernate的方言 --&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 可选配置 --&gt; &lt;!-- 打印SQL --&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;!-- 格式化SQL --&gt; &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt; &lt;!-- 引入映射文件 --&gt; &lt;mapping resource="com/mbc/domain/Customer.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 2.8 创建测试类1234567891011121314151617181920212223242526272829303132package com.mbc.test;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import org.junit.Test;import com.mbc.domain.Customer;public class Test1 &#123; @Test public void test1() &#123; //1.加载Hibernate的核心配置文件 Configuration configure = new Configuration().configure(); //2.创建一个SessionFactory对象：类似以JDBC中的连接池 SessionFactory sessionFactory = configure.buildSessionFactory(); //3.通过SessionFactory获取到Session对象，类似于JDBC中Connection Session session = sessionFactory.openSession(); //4.开启事务 Transaction transaction = session.beginTransaction(); //5.编写代码 Customer customer = new Customer(); customer.setCust_name(&quot;张三&quot;); session.save(customer); //6.提交事务 transaction.commit(); //7.资源释放 session.close(); &#125;&#125; 3. Hibernate的映射的配置1. class标签 作用：建立类与表的映射关系 属性： name：类的全路径 table：表名（类名和表名一致，table可以省略） catalog：数据库名 2. id标签 作用：建立类中的属性与表中的主键的对应关系 属性： name：类中的属性名 column：表中的字段名(类中的属性名和表中的字段名相同，可以省略) length：长度 type：类型 3. property标签 作用：用来建立类中的普通属性与表的字段的对应关系 属性： name：类中的属性名 column：表中的字段名 length：长度 type：类型 not-null：设置非空 unique：设置非一 4. Hibernate的核心配置4.1 Hibernate的核心配置方式1. 属性文件的方式 形如：hibernate.properties的key-value文件，可参考Hibernate目录下project/etc/hibernate.properties文件来进行配置。此种方式需手动加载映射文件。 2. XML文件的方式 即入门程序中hibernate.cfg.xml 4.2 Hibernate的核心配置1. 必须的配置 (1) 连接数据库的基本参数，通过property标签配置 驱动类：hibernate.connection.driver_class url路径：hibernate.connection.url 用户名：hibernate.connection.username 密码：hibernate.connection.password 例如：&lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; (2) Hibernate的方言 &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; 作用：根据配置的方言生成相应数据库的SQL语句 2. 可选的配置 (1) 显示SQL：hibernate.show.sql (2) 格式化SQL：hibernate.format_sql (3) 自动建表：hibernate.hbm2ddl.auto none： 不使用hibernate的自动建表 create：删除数据库中已有的表，重新创建（测试用） create-drop：删除数据库中已有的表，重新创建，使用完后删除该表。（测试用） update：如果数据库中有表，使用原有表，如果没有表，创建新表。(可用于跟新表结构) validate：如果没有表，不会创建表。只会使用数据库中原有的表。（可用于检验映射和表结构） (4) 映射文件的引入 例如：&lt;mapping resource=&quot;com/mbc/domain/Customer.hbm.xml&quot;/&gt; 5. Hibernate中的核心API5.1 Configuration作用：加载核心配置文件。 下面来具体看下两种加载核心配置文件的具体实现。 方式一：属性文件的方式 新建一个属性文件，并命名为hibernate.properties。具体内容如下123456789# 必须的配置hibernate.connection.driver_class=com.mysql.jdbc.Driverhibernate.connection.url=jdbc:mysql://localhost/hibernate_day1hibernate.connection.username=roothibernate.connection.password=root# 可选的配置hibernate.dialect=org.hibernate.dialect.MySQLDialecthibernate.show_sql=truehibernate.format_sql=true 属性文件的方式不支持引入映射表，所以需要手动编码映入映射表。 相应的测试代码：12345678910111213141516171819202122232425262728293031323334353637package com.mbc.test;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import org.junit.Test;import com.mbc.domain.Customer;public class Test1 &#123; @Test public void test1() &#123; //1.加载Hibernate的核心配置文件// Configuration configure = new Configuration().configure(); //核心配置文件为属性文件的方式，默认加载的文件名为hibernate.properties Configuration configure = new Configuration(); //手动加载映射 configure.addResource("com/mbc/domain/Customer.hbm.xml"); //2.创建一个SessionFactory对象：类似以JDBC中的连接池 SessionFactory sessionFactory = configure.buildSessionFactory(); //3.通过SessionFactory获取到Session对象，类似于JDBC中Connection Session session = sessionFactory.openSession(); //4.开启事务 Transaction transaction = session.beginTransaction(); //5.编写代码 Customer customer = new Customer(); customer.setCust_name("张三"); session.save(customer); //6.提交事务 transaction.commit(); //7.资源释放 session.close(); &#125;&#125; 第二种方式：XML文件的方式 入门程序的配置方式即为XML文件的方式。 加载Hibernate的核心配置文件代码如下：1Configuration configure = new Configuration().configure(); 此种方式默认加载的XML文件名为：hibernate.cfg.xml 当然，以XML文件的方式也可以手动引入映射表。和配置文件引入映射表的方法一样。 5.2 SessionFactory作用：SessionFactory内部维护了Hibernate的连接池，是线程安全的对象，一个项目创建一个对象即可。它充当数据存储源的代理，并负责创建Session对象。可以按JDBC的连接池来理解。 为保证一个项目只创建一个SessionFactory对象，我们可以抽取工具类来生成Session对象。1234567891011121314151617181920package com.mbc.util;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class HibernateUtil &#123; public static final Configuration CFG; public static final SessionFactory SF; //使用静态加载的方式来保证SessionFactory对象为单例 static &#123; CFG = new Configuration().configure(); SF = CFG.buildSessionFactory(); &#125; public static Session openSession() &#123; return SF.openSession(); &#125;&#125; 5.3 Session作用：负责执行被持久化对象的CRUD操作(类似JDBC的Connection对象)。非线程安全。 下面介绍Session中的API 1 保存方法1Serializable save(Object object); 123456789101112@Testpublic void testSave() &#123; Session session = HibernateUtil.openSession(); Transaction transaction = session.beginTransaction(); Customer customer = new Customer(); customer.setCust_name("张三"); session.save(customer); transaction.commit(); session.close();&#125; 2 查询方法1T get(Class c, Serializable id); 1T load(Class c, Serializable id); get方法和load方法的区别 (1) 加载方式 get方法采用的是立即加载，执行到这行代码的时候，就会马上发送SQL语句去查询。 load方法采用的延迟加载(lazy，懒加载)，执行到这行代码的时候，不会发送SQL语句。当真正使用这个对象的时候才会发送SQL语句。 (2) 返回的对象 查询到记录时： get方法返回的是查询到的真实对象本身。 load方法返回的是代理对象。利用javassist技术产生的代理。(mark…) 没有查询到记录时： get方法返回的是null load方法返回的是ObjectNotFoundException 1234567891011121314151617@Testpublic void testGetAndLoad() &#123; Session session = HibernateUtil.openSession(); Transaction transaction = session.beginTransaction(); //get：当执行时，会马上发送SQL语句去查询 Customer customer1 = session.get(Customer.class, 1L); System.out.println(customer1); //load：延迟加载 Customer customer2 = session.load(Customer.class, 5L); //当要使用查询的对象时，才发送SQL去查询，即执行以下代码时才发送SQL语句 System.out.println(customer2); transaction.commit(); session.close();&#125; 3. 修改方法1void update(Object obj) 12345678910111213141516171819@Testpublic void testUpdate() &#123; Session session = HibernateUtil.openSession(); Transaction transaction = session.beginTransaction(); //直接创建对象，进行修改 Customer customer1 = new Customer(); customer1.setCust_id(1L); customer1.setCust_name("小明"); session.update(customer1); //先查询，再修改(通常使用这种方法) Customer customer2 = session.get(Customer.class, 5L); customer2.setCust_name("大明"); session.update(customer2); transaction.commit(); session.close();&#125; 4. 删除方法1void delete(Object obj) 1234567891011121314151617@Testpublic void testDelete() &#123; Session session = HibernateUtil.openSession(); Transaction transaction = session.beginTransaction(); //直接创建对象，进行删除 Customer customer1 = new Customer(); customer1.setCust_id(1L); session.delete(customer1); //先查询，再删除(通常使用这种方法，可以级联删除) Customer customer2 = session.get(Customer.class, 5L); session.delete(customer2); transaction.commit(); session.close();&#125; 5. 保存或更新 1void saveOrUpdate(Object obj) 123456789101112131415161718@Testpublic void testSaveOrUpdate() &#123; Session session = HibernateUtil.openSession(); Transaction transaction = session.beginTransaction(); //若数据库中不存在记录，进行保存(save)操作 Customer customer1 = new Customer(); customer1.setCust_name("小小明"); session.saveOrUpdate(customer1); //若数据库中存在记录，进行更新(update)操作 Customer customer2 = session.get(Customer.class, 3L); customer2.setCust_name("大大明"); session.saveOrUpdate(customer2); transaction.commit(); session.close();&#125; 6. 查询所有的记录12345678910111213141516171819202122@Testpublic void testQuery() &#123; Session session = HibernateUtil.openSession(); Transaction transaction = session.beginTransaction(); //通过HQL方式，HQL(Hibernate Query Language)面向对象的查询语言 Query query = session.createQuery("from Customer"); List&lt;Customer&gt; list1 = query.list(); for (Customer customer : list1) &#123; System.out.println(customer); &#125; //通过SQL方式 SQLQuery sqlQuery = session.createSQLQuery("SELECT * FROM cst_customer"); List&lt;Object[]&gt; list2 = sqlQuery.list(); for (Object[] objects : list2) &#123; System.out.println(Arrays.toString(objects)); &#125; transaction.commit(); session.close();&#125; 5.4 Transaction作用：Hibernate中管理事务的对象。 主要方法： commit() rollback()]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git备忘录]]></title>
    <url>%2F2018%2F08%2F07%2FLearnGit%2F</url>
    <content type="text"><![CDATA[Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git是Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 安装git 在Windows上安装Git直接从Git官网上直接下载安装程序，然后按默认选项安装即可。 安装完成后，设置用户名和Email地址12git config --global user.name &quot;Your name&quot;git config --global user.email &quot;email@example.com&quot; 命令中的--global参数，表示当前用户上的所有的Git仓库都会使用这个配置 创建版本库初始化仓库1git init 添加文件到Git仓库两步操作：12git add &lt;file&gt;git commit -m &lt;message&gt; git add可反复多次使用，添加多个文件；git commit的-m参数后面输入的是本次提交的说明。 查看工作区的状态1git status 查看修改内容123git diff git diff --cachedgit diff HEAD &lt;file&gt; git diff 查看工作区和暂存区的区别 git diff --cached 查看暂存区和版本库的区别 git diff HEAD &lt;file&gt; 查看工作区和版本库的区别 查看提交日志1git log 简化日志输出信息1git log --pretty=oneline 查看命令历史1git reflog 版本回退1git reset --hard HEAD^/commit_id 其中HEAD表示当前版本，HEAD^ 表示上一个版本，HEAD^^ 表示上上一个版本。往前100个版本可以写成HEAD~100。 commit_id是版本号，可以通过git log或git reflog 查看提交的历史获取。 撤销修改撤销工作区的修改 手动删除 使用命令1git checkout -- &lt;file&gt; 这里有两种情况：一种是文件自修改后还没有放到暂存区，撤销修改就回到和版本库一模一样；一种是文件已经添加到暂存区，又作了修改，撤销修改就回到了暂存区的状态。 撤销暂存区的修改1git reset HEAD &lt;file&gt; git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。 删除文件123rm &lt;file&gt;git rm &lt;file&gt;git commit -m &lt;message&gt; 或12git rm &lt;file&gt;git commit -m &lt;message&gt; rm &lt;file&gt;从工作区删除文件，git commit把删除文件操作提交到版本库。git rm &lt;file&gt;从工作区和暂存区中删除文件。 若删除错了，可以使用版本库来恢复 远程仓库这里使用GitHub提供的仓库托管服务，由于本地Git仓库和GitHub仓库之间的传输时通过SSH加密的，所以，需要一点设置。 1.创建SSH Key 打开Shell(Git Bash)输入：1ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 然后一路回车，可以在用户目录里找到.ssh目录,里面有id_rsa(秘钥，不能泄露)，id_rsa.pub(公钥，可以告诉任何人)。 2.在GitHub设置ssh 1）登录GitHub 2）打开“Settings”-&gt;”SSH and GPG keys”-&gt;”New SSH key” 3）填写Title,把id_rsa.pub文件的中内容填到Key中，最后“Add SSH key”。 GitHub通过SSH key来识别出提交是否是你推送的。GitHub允许你添加多个key，这样就可以使用多台电脑往同一个GitHub账户中推送。 在GitHub上免费托管的Git仓库，任何人都可以看到（但只有你自己才能改）。所以，不要把敏感信息放进去。 添加远程库1git remote add origin git@github.com:username/repositoryname.git origin是远程仓库名字，Git默认的叫法，可以改为别的。 `git@github.com:username/repositoryname.git可以换为https://github.com/username/repositoryname.git` 实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。 删除远程库1git remote rm origin 查看远程库的信息1git remote 显示更详细的信息：1git remote -v 推送到远程库1git push -u origin master 把分支master推送到远程。-u：第一次推送master分支时，加上了-u参数会把本地的master分支和远程的master分支关联起来,以后推送或者拉取时可以简化命令(git push origin master) 如果要推送其他分支，比如dev，就改成1git push origin dev 克隆远程仓库1git clone git@github.com:username/respositoryname.git 分支 创建分支1git branch &lt;branchname&gt; 查看分支1git branch 切换分支1git checkout &lt;branchname&gt; 创建+切换分支1git checkout -b &lt;branchname&gt; 合并分支到当前分支1git merge &lt;branchname&gt; 删除分支1git branch -d &lt;branchname&gt; -d换为-D可以强行删除一个没有被合并过的分支 查看分支合并情况1git log --graph --pretty=oneline --abbrev-commit 创建远程分支到本地1git checkout -b &lt;branchname&gt; origin/&lt;branchname&gt; 链接本地分支与远程分支1git branch --set-upstream-to=origin/&lt;branchname&gt; &lt;branchname&gt; 分支管理策略 合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后会丢掉分支信息。可以通过禁用Fast forward模式，Git就会在merge时生成一个新的 commit,这样从分支历史上就可以看出分支信息。 1git merge --no-ff -m &lt;message&gt; --no-ff参数，表示禁用Fast forward。合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 分支管理基本原则 1）master分支：是非常稳定的，仅用来发布新版本，平时不能在上面干活；2）dev分支：干活的分支，是不稳定的；要发布时，再把dev合并到master上；3）bug分支：修复bug的分支；4）feature分支：添加新功能； stash stash可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作 保存工作现场1git stash 查看工作现场1git stash list 恢复工作现场1git stash pop 或12git stash applygit stash drop git stash apply 恢复后，stash内容并不删除，你需要用git stash drop来删除git stash pop恢复的同时把stash内容也删了 标签 创建标签1git tag &lt;tagname&gt; 默认标签是打在最新提交的commit上的 创建指定commit_id上标签1git tag &lt;tagname&gt; commit_id 创建带有说明的标签1git tag -a &lt;tagname&gt; -m &lt;message&gt; commit_id -a指定标签名，-m指定说明文字。 查看标签1git tag 查看具体标签信息1git show &lt;tagname&gt; 删除本地标签1git tag -d &lt;tagname&gt; 推送标签到远程仓库1git push origin &lt;tagname&gt; 一次性推送全部尚未推送的本地标签到远程1git push origin --tags 删除远程标签先本地删除，再远程删除1git tag -d &lt;tagname&gt; 1git push origin :refs/tags/&lt;tagname&gt; GitHub (1)免费的远程仓库(2)一个开源协作社区 如何参与一个开源项目？1）点“Fork”就在自己的账号下克隆一个仓库 2）然后从自己的账号下clone 3)推送修改到自己的仓库 4）在GitHub上发起pull request 自定义Git 让Git显示颜色1git config --global color.ui true 忽略特殊文件 在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理. 不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore 文件被.gitignore忽略了,可以用-f强制添加到Git1git add -f &lt;file&gt; 配置别名 告诉Git，以后st就表示status1git config --global alist.st status 常用命令的别名配置123git config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.br branch 配置文件 配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。每个仓库的Git配置文件都放在.git/config文件中，当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
</search>
